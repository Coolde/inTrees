# This is file is temporary
rm(list=ls(all=TRUE))
library(randomForest);
library(RRF);
graphics.off()
sourceDir <- function(path, trace = TRUE) {
for (nm in list.files(path, pattern = "\\.[Rr]$")) {
if(trace) cat(nm)
source(file.path(path, nm))
if(trace) cat("\n")
}
}
sourceDir("devR/")
# Test XGBoost
require(data.table)
require(xgboost)
# test data set 1: iris
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 50,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat,digits=3)
ruleExec <- unique(ruleExec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(ruleExec),min(2000,length(ruleExec))) #randomly select 2000 rules
ruleExec <- ruleExec[ix,,drop=FALSE]
ruleMetric <- getRuleMetric(ruleExec,model_mat,Y)
ruleMetric <- pruneRule(ruleMetric,model_mat,Y,typeDecay = 1)
ruleSelect <- selectRuleRRF(ruleMetric, model_mat, Y)
ruleMetric <- unique(ruleMetric)
tree_list <- XGB2List(xgb,model_mat)
tree_list
model_mat
ruleExec <- extractRules(tree_list,model_mat,digits=3)
ruleExec <- unique(ruleExec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(ruleExec),min(2000,length(ruleExec))) #randomly select 2000 rules
ruleExec <- ruleExec[ix,,drop=FALSE]
ruleMetric <- getRuleMetric(ruleExec,model_mat,Y)
ruleMetric <- pruneRule(ruleMetric,model_mat,Y,typeDecay = 1)
ruleSelect <- selectRuleRRF(ruleMetric, model_mat, Y)
ruleMetric <- unique(ruleMetric)
ruleExec
ruleExec <- extractRules(tree_list,model_mat,digits=3)
ruleExec <- extractRules(tree_list,model_mat)
debug(extractRules)
ruleExec <- extractRules(tree_list,model_mat)
levels
levelX
undebug(extractRules.R)
undebug(extractRules)
debug(singleRuleList2Exec)
ruleExec <- extractRules(tree_list,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
undebug(singleRuleList2Exec)
singleRuleList2Exec <-
function(ruleList,typeX){ #numeric: 1; categorical: 2s
#ruleExec <- "which("
ruleExec <- ""
vars <- ls(ruleList)
#ruleL <- length(unique(vars))
vars <- vars[order(as.numeric(vars))]
for(i in 1:length(vars)){
if(typeX[as.numeric(vars[i])]==2){
values <- paste("c(",paste(  paste("'",ruleList[[vars[i]]],"'",sep="")    ,collapse=","),")",sep="")
tmp = paste("X[,",vars[i], "] %in% ", values, sep="")
}else{
tmp = ruleList[[vars[i]]]
}
if(i==1)ruleExec <- paste(ruleExec, tmp,sep="")
if(i>1)ruleExec <- paste(ruleExec, " & ", tmp, sep="")
}
print("t")
#ruleExec <- paste(ruleExec,")",sep="")
return(c(ruleExec))
}
undebug(singleRuleList2Exec)
ruleExec <- extractRules(tree_list,model_mat)
singleRuleList2Exec <-
function(ruleList,typeX){ #numeric: 1; categorical: 2s
#ruleExec <- "which("
print("t1")
ruleExec <- ""
vars <- ls(ruleList)
#ruleL <- length(unique(vars))
vars <- vars[order(as.numeric(vars))]
for(i in 1:length(vars)){
if(typeX[as.numeric(vars[i])]==2){
values <- paste("c(",paste(  paste("'",ruleList[[vars[i]]],"'",sep="")    ,collapse=","),")",sep="")
tmp = paste("X[,",vars[i], "] %in% ", values, sep="")
}else{
tmp = ruleList[[vars[i]]]
}
if(i==1)ruleExec <- paste(ruleExec, tmp,sep="")
if(i>1)ruleExec <- paste(ruleExec, " & ", tmp, sep="")
}
print("t2")
#ruleExec <- paste(ruleExec,")",sep="")
return(c(ruleExec))
}
ruleExec <- extractRules(tree_list,model_mat)
singleRuleList2Exec <-
function(ruleList,typeX){ #numeric: 1; categorical: 2s
#ruleExec <- "which("
print("t1")
ruleExec <- ""
vars <- ls(ruleList)
#ruleL <- length(unique(vars))
vars <- vars[order(as.numeric(vars))]
print(vars)
print(ruleList)
for(i in 1:length(vars)){
if(typeX[as.numeric(vars[i])]==2){
values <- paste("c(",paste(  paste("'",ruleList[[vars[i]]],"'",sep="")    ,collapse=","),")",sep="")
tmp = paste("X[,",vars[i], "] %in% ", values, sep="")
}else{
tmp = ruleList[[vars[i]]]
}
if(i==1)ruleExec <- paste(ruleExec, tmp,sep="")
if(i>1)ruleExec <- paste(ruleExec, " & ", tmp, sep="")
}
print("t2")
#ruleExec <- paste(ruleExec,")",sep="")
return(c(ruleExec))
}
ruleExec <- extractRules(tree_list,model_mat)
extractRules <-
function(treeList,X,ntree=100,maxdepth=6,random=FALSE,digits=NULL){
if(is.numeric(digits)) digits <- as.integer(abs(digits))
levelX = list()
for(iX in 1:ncol(X))
levelX <- c(levelX,list(levels(X[,iX])))
# X <- NULL; target <- NULL
ntree=min(treeList$ntree,ntree)
allRulesList = list()
for(iTree in 1:ntree){
if(random==TRUE){max_length = sample(1:maxdepth,1,replace=FALSE)}else{
max_length = maxdepth}
rule = list(); count = 0; rowIx = 1;
# tree = getTree(rf,iTree,labelVar=FALSE)
tree <- treeList$list[[iTree]]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
res = treeVisit(tree,rowIx = rowIx,count,ruleSet,rule,levelX,length=0,max_length=max_length,digits=digits)
allRulesList = c(allRulesList, res$ruleSet)
}
allRulesList <- allRulesList[!unlist(lapply(allRulesList, is.null))]
cat(paste(length(allRulesList)," rules (length<=",
max_length, ") were extracted from the first ", ntree," trees.","\n",sep=""))
print(allRulesList)
rulesExec <- ruleList2Exec(X,allRulesList)
return(rulesExec)
}
ruleExec <- extractRules(tree_list,model_mat)
singleRuleList2Exec <-
function(ruleList,typeX){ #numeric: 1; categorical: 2s
#ruleExec <- "which("
#print("t1")
ruleExec <- ""
vars <- ls(ruleList)
#ruleL <- length(unique(vars))
vars <- vars[order(as.numeric(vars))]
#print(vars)
#print(ruleList)
for(i in 1:length(vars)){
if(typeX[as.numeric(vars[i])]==2){
values <- paste("c(",paste(  paste("'",ruleList[[vars[i]]],"'",sep="")    ,collapse=","),")",sep="")
tmp = paste("X[,",vars[i], "] %in% ", values, sep="")
}else{
tmp = ruleList[[vars[i]]]
}
if(i==1)ruleExec <- paste(ruleExec, tmp,sep="")
if(i>1)ruleExec <- paste(ruleExec, " & ", tmp, sep="")
}
#print("t2")
#ruleExec <- paste(ruleExec,")",sep="")
return(c(ruleExec))
}
source('~/intrees/inTrees/Test/Test_devR.r', echo=TRUE)
extractRules <-
function(treeList,X,ntree=100,maxdepth=6,random=FALSE,digits=NULL){
if(is.numeric(digits)) digits <- as.integer(abs(digits))
levelX = list()
for(iX in 1:ncol(X))
levelX <- c(levelX,list(levels(X[,iX])))
# X <- NULL; target <- NULL
ntree=min(treeList$ntree,ntree)
allRulesList = list()
for(iTree in 1:ntree){
if(random==TRUE){max_length = sample(1:maxdepth,1,replace=FALSE)}else{
max_length = maxdepth}
rule = list(); count = 0; rowIx = 1;
# tree = getTree(rf,iTree,labelVar=FALSE)
tree <- treeList$list[[iTree]]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
res = treeVisit(tree,rowIx = rowIx,count,ruleSet,rule,levelX,length=0,max_length=max_length,digits=digits)
allRulesList = c(allRulesList, res$ruleSet)
}
allRulesList <- allRulesList[!unlist(lapply(allRulesList, is.null))]
cat(paste(length(allRulesList)," rules (length<=",
max_length, ") were extracted from the first ", ntree," trees.","\n",sep=""))
rulesExec <- ruleList2Exec(X,allRulesList)
return(rulesExec)
}
ruleExec <- extractRules(tree_list,model_mat)
# Test XGBoost
require(data.table)
require(xgboost)
# test data set 1: iris
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 50,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
# Test XGBoost
require(data.table)
require(xgboost)
# test data set 1: iris
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 20,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 50,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
tree_list
debug(ruleList2Exec)
ruleExec <- extractRules(tree_list,model_mat)
dim(allRulesList)
length(allRulesList)
allRulesList
extractRules <-
function(treeList,X,ntree=100,maxdepth=6,random=FALSE,digits=NULL){
if(is.numeric(digits)) digits <- as.integer(abs(digits))
levelX = list()
for(iX in 1:ncol(X))
levelX <- c(levelX,list(levels(X[,iX])))
# X <- NULL; target <- NULL
ntree=min(treeList$ntree,ntree)
allRulesList = list()
for(iTree in 1:ntree){
if(random==TRUE){max_length = sample(1:maxdepth,1,replace=FALSE)}else{
max_length = maxdepth}
rule = list(); count = 0; rowIx = 1;
# tree = getTree(rf,iTree,labelVar=FALSE)
tree <- treeList$list[[iTree]]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
res = treeVisit(tree,rowIx = rowIx,count,ruleSet,rule,levelX,length=0,max_length=max_length,digits=digits)
print(res)
allRulesList = c(allRulesList, res$ruleSet)
}
allRulesList <- allRulesList[!unlist(lapply(allRulesList, is.null))]
cat(paste(length(allRulesList)," rules (length<=",
max_length, ") were extracted from the first ", ntree," trees.","\n",sep=""))
rulesExec <- ruleList2Exec(X,allRulesList)
return(rulesExec)
}
ruleExec <- extractRules(tree_list,model_mat)
extractRules <-
function(treeList,X,ntree=100,maxdepth=6,random=FALSE,digits=NULL){
if(is.numeric(digits)) digits <- as.integer(abs(digits))
levelX = list()
for(iX in 1:ncol(X))
levelX <- c(levelX,list(levels(X[,iX])))
# X <- NULL; target <- NULL
ntree=min(treeList$ntree,ntree)
allRulesList = list()
for(iTree in 1:ntree){
if(random==TRUE){max_length = sample(1:maxdepth,1,replace=FALSE)}else{
max_length = maxdepth}
rule = list(); count = 0; rowIx = 1;
# tree = getTree(rf,iTree,labelVar=FALSE)
tree <- treeList$list[[iTree]]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
res = treeVisit(tree,rowIx = rowIx,count,ruleSet,rule,levelX,length=0,max_length=max_length,digits=digits)
print(tree)
allRulesList = c(allRulesList, res$ruleSet)
}
allRulesList <- allRulesList[!unlist(lapply(allRulesList, is.null))]
cat(paste(length(allRulesList)," rules (length<=",
max_length, ") were extracted from the first ", ntree," trees.","\n",sep=""))
rulesExec <- ruleList2Exec(X,allRulesList)
return(rulesExec)
}
extractRules <-
function(treeList,X,ntree=100,maxdepth=6,random=FALSE,digits=NULL){
if(is.numeric(digits)) digits <- as.integer(abs(digits))
levelX = list()
for(iX in 1:ncol(X))
levelX <- c(levelX,list(levels(X[,iX])))
# X <- NULL; target <- NULL
ntree=min(treeList$ntree,ntree)
allRulesList = list()
for(iTree in 1:ntree){
if(random==TRUE){max_length = sample(1:maxdepth,1,replace=FALSE)}else{
max_length = maxdepth}
rule = list(); count = 0; rowIx = 1;
# tree = getTree(rf,iTree,labelVar=FALSE)
tree <- treeList$list[[iTree]]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
res = treeVisit(tree,rowIx = rowIx,count,ruleSet,rule,levelX,length=0,max_length=max_length,digits=digits)
print(tree)
allRulesList = c(allRulesList, res$ruleSet)
}
allRulesList <- allRulesList[!unlist(lapply(allRulesList, is.null))]
cat(paste(length(allRulesList)," rules (length<=",
max_length, ") were extracted from the first ", ntree," trees.","\n",sep=""))
rulesExec <- ruleList2Exec(X,allRulesList)
return(rulesExec)
}
# Test XGBoost
require(data.table)
require(xgboost)
# test data set 1: iris
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 50,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
extractRules <-
function(treeList,X,ntree=100,maxdepth=6,random=FALSE,digits=NULL){
if(is.numeric(digits)) digits <- as.integer(abs(digits))
levelX = list()
for(iX in 1:ncol(X))
levelX <- c(levelX,list(levels(X[,iX])))
# X <- NULL; target <- NULL
ntree=min(treeList$ntree,ntree)
allRulesList = list()
for(iTree in 1:ntree){
if(random==TRUE){max_length = sample(1:maxdepth,1,replace=FALSE)}else{
max_length = maxdepth}
rule = list(); count = 0; rowIx = 1;
# tree = getTree(rf,iTree,labelVar=FALSE)
tree <- treeList$list[[iTree]]
if(nrow(tree)<=1) next
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
res = treeVisit(tree,rowIx = rowIx,count,ruleSet,rule,levelX,length=0,max_length=max_length,digits=digits)
allRulesList = c(allRulesList, res$ruleSet)
}
allRulesList <- allRulesList[!unlist(lapply(allRulesList, is.null))]
cat(paste(length(allRulesList)," rules (length<=",
max_length, ") were extracted from the first ", ntree," trees.","\n",sep=""))
rulesExec <- ruleList2Exec(X,allRulesList)
return(rulesExec)
}
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
undebug(ruleList2Exec)
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 150,objective = "binary:logistic" )
tree_list <- XGB2List(xgb,model_mat)
ruleExec <- extractRules(tree_list,model_mat)
require(data.table)
require(xgboost)
# test data set 1: iris
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 500,objective = "multi:softprob", num_class = 3 )
ruleExec <- extractRules(tree_list,model_mat)
uleExec <- unique(ruleExec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(ruleExec),min(2000,length(ruleExec))) #randomly select 2000 rules
ruleExec <- ruleExec[ix,,drop=FALSE]
ruleMetric <- getRuleMetric(ruleExec,model_mat,Y)
ruleMetric <- pruneRule(ruleMetric,model_mat,Y,typeDecay = 1)
ruleSelect <- selectRuleRRF(ruleMetric, model_mat, Y)
ruleMetric <- unique(ruleMetric)
ruleClassifier <- buildLearner(ruleMetric,model_mat,Y)
readable <- presentRules(ruleClassifier,colnames(model_mat),digits=3)
pred <- applyLearner(ruleClassifier,model_mat)
errXGBoost=1-sum(pred==Y)/length(pred);
errXGBoost
