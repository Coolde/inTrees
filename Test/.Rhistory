treeList$list[[1]][1:2]
treeList$list[[1]]
treeList <- RF2List(rf)
treeList$list[[1]]
treeList1$list
treeList1
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList=lapply(treeList1,formatXGB)
treeList
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList=lapply(treeList1$list,formatXGB)
treeList
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
X1 <- data.table(X, keep.rownames = F)
sparse_matrix <- sparse.model.matrix(X20~., data=X)
xgb <- xgboost(sparse_matrix, label = as.numeric(Y) - 1, nrounds = 10 )
feature_names <- colnames(sparse_matrix)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
treeList1$list
xt
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt
X1 <- data.table(X, keep.rownames = F)
sparse_matrix <- sparse.model.matrix(X20~., data=X)
xgb <- xgboost(sparse_matrix, label = as.numeric(Y) - 1, nrounds = 2,objective = "binary:logistic" )
feature_names <- colnames(sparse_matrix)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList=lapply(treeList1$list,formatXGB)
treeList
sparse_matrix
X
colnames(sparse_matrix)
sparse_matrix
dim(X)
feature_names
sparse_matrix <- model.matrix(X20~., data=X)
sparse_matrix
xgb <- xgboost(sparse_matrix, label = as.numeric(Y) - 1, nrounds = 2,objective = "binary:logistic" )
feature_names <- colnames(sparse_matrix)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
sparse_matrix
summary(sparse_matrix)
sparse_matrix
xgb <- xgboost(sparse_matrix, label = as.numeric(Y) - 1, nrounds = 2,objective = "binary:logistic" )
feature_names <- colnames(sparse_matrix)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList=lapply(treeList1$list,formatXGB)
treeList
ruleExec <- extractRules(treeList$list,X)
treeList$list
treeList
ruleExec <- extractRules(treeList,sparse_matrix)
treeList
extractRules(treeList,sparse_matrix)
debug(extractRules)
extractRules(treeList,sparse_matrix)
levelX
rowIx
tree
ruleSet
treeList$list
iTree
treeList
treeList
treeList<-split(xt, by="Tree")
treeList
treeList<-split(xt, by="Tree")
treeList
treeList<-split(xt, by="Tree")
treeList
treeList<-split(xt, by="Tree")
treeList
treeList<-split(xt, by="Tree")
treeList<-split(xt, by="Tree")
treeList
treeList<-split(xt, by="Tree")
treeList<-split(xt, by="Tree")
treeList=lapply(treeList,formatXGB)
treeList<-split(xt, by="Tree")
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
ruleExec <- extractRules(treeList,sparse_matrix)
ruleExec <- extractRules(treeList,sparse_matrix)
ruleExec
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
treeList
ruleExec <- extractRules(treeList,sparse_matrix)
debug(extractRules)
ruleExec <- extractRules(treeList,sparse_matrix)
debug(extractRules)
ruleExec <- extractRules(treeList,sparse_matrix)
undebug(extractRules)
ruleExec <- extractRules(treeList,sparse_matrix)
debug(extractRules)
treeList
ruleExec <- extractRules(treeList,sparse_matrix)
ruleSet
ruleExec <- extractRules(treeList,sparse_matrix)
tree
tree
ruleExec <- extractRules(treeList,sparse_matrix)
treeList$list
tree <- treeList$list[[iTree]]
tree
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
ruleSet
levelX
ruleSet
rule
rowIx
rowIx
count
tree
tree
debug(treeVisit)
ruleExec <- extractRules(treeList,sparse_matrix)
ntree
treeList
tree
ruleExec <- extractRules(treeList,sparse_matrix)
tree
summary(tree)
tree$`split point`
as.numeric(tree$`split point`)
treeList$list
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a$`split point` <- as.numeric(a$`split point`)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
undebug(extractRules)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a$`split point` <- as.numeric(a$`split point`)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
ruleExec <- extractRules(treeList,sparse_matrix)
undebug(extractRules)
X1 <- data.table(X, keep.rownames = F)
sparse_matrix <- model.matrix(X20~., data=X)
xgb <- xgboost(sparse_matrix, label = as.numeric(Y) - 1, nrounds = 2,objective = "binary:logistic" )
feature_names <- colnames(sparse_matrix)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a$`split point` <- as.numeric(a$`split point`)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
ruleExec <- extractRules(treeList,sparse_matrix)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a$`split point` <- as.numeric(a$`split point`)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
treeList
treeList$list
debug()
debug(extractRules)
ruleExec <- extractRules(treeList,sparse_matrix)
tree
tree[rowIx,"status"]
xIx
xValue
ruleExec <- extractRules(treeList,sparse_matrix)
ruleExec <- extractRules(treeList,sparse_matrix)
ruleExec <- extractRules(treeList,sparse_matrix)
tree
levelX
ruleExec <- extractRules(treeList,sparse_matrix)
tree[,"status"]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
ruleSet
tree[,"status"]==-1
tree <- treeList$list[[iTree]]
ruleSet = vector("list", length(which(tree[,"status"]==-1)))
ruleSet
ruleExec <- extractRules(treeList,sparse_matrix)
ruleSet
xIx
levelX
sparse_matrix
ruleExec <- extractRules(treeList,sparse_matrix)
X[,iX]
levels(X[,iX]
)
X[1:4,]
tree
treeList
ntree
levelX
list(levels(X[,iX]))
treeList <- RF2List(rf)
ruleExec <- extractRules(treeList,X)
X[,iX]
X
iX = 8
levels(X[,iX])
levelX
debug(treeVisit)
treeList$list=lapply(treeList1$list,formatXGB)
ruleExec <- extractRules(treeList,sparse_matrix)
treeList
X[1:3,]
ruleExec <- extractRules(treeList,sparse_matrix)
levelX
levelX[[xIx]]
summary(levelX)
class(levelX)
levelX[1]
levelX[[1]
]
xIx
tree
tree[1,"split var"]
class(tree[1,"split var"])
class(tree)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
a <- tree
rownames(a) <- 1:nrow(a)
a$status <- ifelse(a$`split var`==-1,-1,1)
a$`split point` <- as.numeric(a$`split point`)
a <- a[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- a$MissingNode[which(a$MissingNode>0)]
if(length(ix)>0)  a$status[ix] <- 10 #missing #a <- a[-ix,]
a <- a[,c("left daughter","right daughter","split var","split point","status")]
}
treeList$list=lapply(treeList1$list,formatXGB)
treeList
treeList$list[[1]]
treeList$list[[1]][1,"split var"]
class(treeList$list[[1]][1,"split var"])
class(treeList$list)
class(treeList$list[[1]])
class(as.data.frame(treeList$list[[1]]))
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
rownames(tree) <- 1:nrow(tree)
tree$status <- ifelse(tree$`split var`==-1,-1,1)
tree$`split point` <- as.numeric(tree$`split point`)
tree <- tree[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- tree$MissingNode[which(tree$MissingNode>0)]
if(length(ix)>0)  tree$status[ix] <- 10 #missing
tree <- tree[,c("left daughter","right daughter","split var","split point","status")]
tree <- as.data.frame(tree)
}
treeList$list=lapply(treeList1$list,formatXGB)
xt<-xgb.model.dt.tree(feature_names = as.character(1:length(feature_names)), model=xgb)
xt[Feature == 'Leaf', Feature := '-1']
xt[, 'split var' := as.integer(Feature)]
xt[, 'split point' := ifelse(`split var` > -1, Split, Quality)]
xt[, 'left daughter' := as.integer(tstrsplit(Yes, '-')[[2]]) + 1]
xt[, 'right daughter' := as.integer(tstrsplit(No, '-')[[2]]) + 1]
xt[, MissingNode := as.integer(tstrsplit(Missing, '-')[[2]]) + 1]
xt[, Weight := Cover]
xt[, Prediction := Quality]
xt[, Node := Node + 1]
xt[, c('ID', 'Yes', 'No', 'Split','Missing', 'Quality', 'Cover', 'Feature') := NULL]
for (f in c('left daughter', 'right daughter', 'MissingNode'))
set(xt, which(is.na(xt[[f]])), f, -1)
treeList1 <- list()
treeList1$ntree <-length(xt)
treeList1$list <- split(xt, by="Tree")
formatXGB <-
function(tree){
rownames(tree) <- 1:nrow(tree)
tree$status <- ifelse(tree$`split var`==-1,-1,1)
tree$`split point` <- as.numeric(tree$`split point`)
tree <- tree[,c("left daughter","right daughter","MissingNode","split var","split point","status")]
ix <- tree$MissingNode[which(tree$MissingNode>0)]
if(length(ix)>0)  tree$status[ix] <- 10 #missing
tree <- tree[,c("left daughter","right daughter","split var","split point","status")]
tree <- as.data.frame(tree)
}
treeList$list=lapply(treeList1$list,formatXGB)
treeList$list[[1]]
treeList$list[[1]][1,"split var"]
undebug(extractRules)
extractRules
ruleExec <- extractRules(treeList,sparse_matrix)
rule
lValue
ruleExec
sparse_matrix
treeList
ruleExec <- extractRules(treeList,sparse_matrix)
rule
xIx
rValue
thisList
ruleSet
ruleExec <- extractRules(treeList,sparse_matrix)
ruleExec <- extractRules(treeList,sparse_matrix)
undebug(treeVisit)
ruleExec <- extractRules(treeList,sparse_matrix)
