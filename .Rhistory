library(xgboost)
library(inTrees)
# test data set 1: iris
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 50,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
rule_exec <- unique(rule_exec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(rule_exec),min(2000,length(rule_exec))) #randomly select 2000 rules
rule_exec <- rule_exec[ix,,drop=FALSE]
rule_metric <- getrule_metric(rule_exec,model_mat,Y)
freq_patterns <- getFreqPattern(rule_metric)
rule_metric <- pruneRule(rule_metric,model_mat,Y,typeDecay = 1)
rule_select <- selectRuleRRF(rule_metric, model_mat, Y)
rule_metric <- unique(rule_metric)
rule_classifier <- buildLearner(rule_metric,model_mat,Y)
readable <- presentRules(rule_classifier,colnames(model_mat),digits=3)
pred <- applyLearner(rule_classifier,model_mat)
print( 1-sum(pred==Y)/length(pred) )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
model_mat
rule_exec <- extractRules(tree_list,model_mat,digits=3)
rule_exec
tree_list
model_mat
rule_exec <- extractRules(tree_list,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
library(xgboost)
library(inTrees)
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 50,objective = "multi:softprob", num_class = 3 )
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 4,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 40,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
library(xgboost)
library(inTrees)
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 40,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
rule_exec <- unique(rule_exec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(rule_exec),min(2000,length(rule_exec))) #randomly select 2000 rules
rule_exec <- rule_exec[ix,,drop=FALSE]
rule_metric <- getrule_metric(rule_exec,model_mat,Y)
freq_patterns <- getFreqPattern(rule_metric)
rule_metric <- pruneRule(rule_metric,model_mat,Y,typeDecay = 1)
rule_select <- selectRuleRRF(rule_metric, model_mat, Y)
rule_metric <- unique(rule_metric)
rule_classifier <- buildLearner(rule_metric,model_mat,Y)
readable <- presentRules(rule_classifier,colnames(model_mat),digits=3)
pred <- applyLearner(rule_classifier,model_mat)
print( 1-sum(pred==Y)/length(pred) )
rule_metric <- getRuleMetric(rule_exec,model_mat,Y)
library(xgboost)
library(inTrees)
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 40,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
rule_exec <- unique(rule_exec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(rule_exec),min(2000,length(rule_exec))) #randomly select 2000 rules
rule_exec <- rule_exec[ix,,drop=FALSE]
rule_metric <- getRuleMetric(rule_exec,model_mat,Y)
freq_patterns <- getFreqPattern(rule_metric)
rule_metric <- pruneRule(rule_metric,model_mat,Y,typeDecay = 1)
rule_select <- selectRuleRRF(rule_metric, model_mat, Y)
rule_metric <- unique(rule_metric)
rule_classifier <- buildLearner(rule_metric,model_mat,Y)
readable <- presentRules(rule_classifier,colnames(model_mat),digits=3)
pred <- applyLearner(rule_classifier,model_mat)
print( 1-sum(pred==Y)/length(pred) )
freq_patterns
?freq_patterns
?getFreqPattern
freq_patterns <- getFreqPattern(rule_metric,maxlen = 4)
freq_patterns <- getFreqPattern(rule_metric,maxlen = 3)
debug(getFreqPattern)
freq_patterns <- getFreqPattern(rule_metric,maxlen = 3)
freq_patterns <- getFreqPattern(rule_metric,maxlen = 3)
freq_patterns <- getFreqPattern(rule_metric,maxlen = 3)
rules1 <- apriori(trans1, parameter = list(supp = minsup,
conf = minconf, minlen = minlen, maxlen = maxlen), control = list(verbose = FALSE),
appearance = list(none = NULL, rhs = yrhs, default = "lhs"))
ruleMetric
library(xgboost)
library(inTrees)
X <- within(iris,rm("Species")); Y <- iris[,"Species"]
model_mat <- model.matrix(~. -1, data=X)
xgb <- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 40,objective = "multi:softprob", num_class = 3 )
tree_list <- XGB2List(xgb,model_mat)
rule_exec <- extractRules(tree_list,model_mat,digits=3)
rule_exec <- unique(rule_exec) # remove same rules. NOTE: for variable interaction analysis, you should NOT perform this step
ix <- sample(1:length(rule_exec),min(2000,length(rule_exec))) #randomly select 2000 rules
rule_exec <- rule_exec[ix,,drop=FALSE]
rule_metric <- getRuleMetric(rule_exec,model_mat,Y)
# freq_patterns <- getFreqPattern(rule_metric,maxlen = 3) # can be less useful for numeric variables.
rule_metric <- pruneRule(rule_metric,model_mat,Y,typeDecay = 1)
rule_select <- selectRuleRRF(rule_metric, model_mat, Y)
rule_metric <- unique(rule_metric)
rule_classifier <- buildLearner(rule_metric,model_mat,Y)
readable <- presentRules(rule_classifier,colnames(model_mat),digits=3)
pred <- applyLearner(rule_classifier,model_mat)
print( 1-sum(pred==Y)/length(pred) )
